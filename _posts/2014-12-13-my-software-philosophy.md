---
layout: post
title: "My Software Philosophy"
description: "How I approach software and use it to make people's lives easier."
category: 
tags: ['Software']
---

Software is everywhere. In our pockets, in our cars, and in our houses. If you get really fancy you can even use your phone, while in your car, to control your house. 

Is that a good thing? Depends on who you ask.

I think great software needs to accomplish one thing. <b>It needs to make your life easier.</b> 

That's the entirety of my software philosophy. Software is simply a tool to get things done. Sure it is more complicated than a hammer or a table saw, still it is the exact same thing. You want to do something, and software might be the right tool for the job. 

You may have different thoughts, maybe you are asking yourself some of these questions:

<b>Does great software need to look "good"?</b>

Sure, great software can look "good", maybe even great although I don't think it is a requirement for it to make your life easier. 

A lot of software I use in my <a href="http://corsosystems.com">day job</a> looks terrible but is way easier than the alternative of doing things the way they were done before the software existed. I think something like <a href="https://draftin.com/">Draft</a> is also great software that eschews eye-popping design for amazing functionality.

Awesome looking is a feature not a benefit. 

<b>Should great software be easy to use?</b>

If great software makes your life easier at first it only needs be easier to use than doing the task without the software. In some cases easier than the alternative is still a pain in the ass. 

From my experience an example of this is <a href="http://www.blender.org">Blender</a>. For a non-sculptor Blender makes the process of 3D modeling way easier the alternative of sculpting something by hand. It is an uphill battle every time I open the program, but at the end of the day I am usually happy with the results.

I am not saying great software needs to be difficult to use, nor should it wear that as a badge of honor and not improve usability as development continues. I am simply saying that software can be less of a nightmare to use than the alternative and still be great.

If a piece of software is truly great it will eventually need to be easy to use. If it doesn't become easier to use someone else will come along and make your software the hassle-some alternative and steal your customers.

<b>Does great software need to integrate with all of your devices, tasks, interactions?</b>

No. Great software can stand on its own. If integrating with everything across the universe helps make your life easier than by all means include that as part of your specifications but don't start with that in mind.

<b>What happens if software doesn't make life easier?</b>

If a piece of software doesn't make life easier for someone it will eventually die off. The list here would be endless if I sat down and compiled it. I will, for the sake of argument, go through one example from my lifetime.

Libraries -> Encyclopedias -> Microsoft Encarta -> The Internet -> Wikipedia

When I was in school the only way to get information was to go to the library and find the right books. At some point someone compiled a lot of potentially useful information in an encyclopedia. Microsoft replicated this concept on the PC with Encarta. That was back in the days when we had a Pentium 75 processor and 750 MB of hard drive space. I couldn't even play Quake 2 on my home PC when it came out. Encarta was doomed when the Internet started becoming available to all of the grubby little kids like myself. Using the Internet was sure easier than an encyclopedia and had more information than Encarta but was like going back to the library. Along comes Wikipedia to start the cycle over again, becoming the encylopedia to the Internet library.

<b>Wrapping Up</b>

Find a problem, make it easier to solve than existing methods, and keep working on it. You might pick problems no one else has and find difficulty in gaining traction. If that is the case pick new problems until you find a good one and keep improving the tools to solve it.


